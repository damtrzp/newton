{"ast":null,"code":"import _toConsumableArray from \"/home/programowanie/newton-rhapson/newton/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'fft';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'divideScalar', 'exp', 'tau', 'i'];\nexport var createFft = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      addScalar = _ref.addScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      divideScalar = _ref.divideScalar,\n      exp = _ref.exp,\n      tau = _ref.tau,\n      I = _ref.i;\n  /**\n   * Calculate N-dimensional fourier transform\n   *\n   * Syntax:\n   *\n   *     math.fft(arr)\n   *\n   * Examples:\n   *\n   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]\n   *\n   *\n   * See Also:\n   *\n   *      ifft\n   *\n   * @param {Array | Matrix} arr    An array or matrix\n   * @return {Array | Matrix}       N-dimensional fourier transformation of the array\n   */\n\n  return typed(name, {\n    Array: _ndFft,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_ndFft(matrix.toArray()));\n    }\n  });\n  /**\n   * Perform an N-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n\n  function _ndFft(arr) {\n    var size = arraySize(arr);\n    if (size.length === 1) return _fft(arr, size[0]); // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0\n\n    return _1dFft(arr.map(function (slice) {\n      return _ndFft(slice, size.slice(1));\n    }), 0);\n  }\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @param {number} dim     dimension of the array to perform on\n   * @return {Array}         resulting array\n   */\n\n\n  function _1dFft(arr, dim) {\n    var size = arraySize(arr);\n    if (dim !== 0) return new Array(size[0]).fill(0).map(function (_, i) {\n      return _1dFft(arr[i], dim - 1);\n    });\n    if (size.length === 1) return _fft(arr);\n\n    function _transpose(arr) {\n      // Swap first 2 dimensions\n      var size = arraySize(arr);\n      return new Array(size[1]).fill(0).map(function (_, j) {\n        return new Array(size[0]).fill(0).map(function (_, i) {\n          return arr[i][j];\n        });\n      });\n    }\n\n    return _transpose(_1dFft(_transpose(arr), 1));\n  }\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n\n\n  function _fft(arr) {\n    var len = arr.length;\n    if (len === 1) return [arr[0]];\n\n    if (len % 2 === 0) {\n      var ret = [].concat(_toConsumableArray(_fft(arr.filter(function (_, i) {\n        return i % 2 === 0;\n      }), len / 2)), _toConsumableArray(_fft(arr.filter(function (_, i) {\n        return i % 2 === 1;\n      }), len / 2)));\n\n      for (var k = 0; k < len / 2; k++) {\n        var p = ret[k];\n        var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));\n        ret[k] = addScalar(p, q);\n        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));\n      }\n\n      return ret;\n    }\n\n    throw new Error('Can only calculate FFT of power-of-two size');\n  }\n});","map":null,"metadata":{},"sourceType":"module"}