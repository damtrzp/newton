{"ast":null,"code":"/*!\n* chartjs-plugin-zoom v1.2.1\n* undefined\n * (c) 2016-2022 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign } from 'chart.js/helpers';\n\nvar getModifierKey = function getModifierKey(opts) {\n  return opts && opts.enabled && opts.modifierKey;\n};\n\nvar keyPressed = function keyPressed(key, event) {\n  return key && event[key + 'Key'];\n};\n\nvar keyNotPressed = function keyNotPressed(key, event) {\n  return key && !event[key + 'Key'];\n};\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\n\n\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart: chart\n    }).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\n\n\nfunction debounce(fn, delay) {\n  var timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n/** This function use for check what axis now under mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\n\n\nfunction getScaleUnderPoint(_ref, chart) {\n  var x = _ref.x,\n      y = _ref.y;\n  var scales = chart.scales;\n  var scaleIds = Object.keys(scales);\n\n  for (var i = 0; i < scaleIds.length; i++) {\n    var scale = scales[scaleIds[i]];\n\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n\n  return null;\n}\n/** This function return only one scale whose position is under mouse cursor and which direction is enabled.\n * If under mouse hasn't scale, then return all other scales which 'mode' is diffrent with overScaleMode.\n * So 'overScaleMode' works as a limiter to scale the user-selected scale (in 'mode') only when the cursor is under the scale,\n * and other directions in 'mode' works as before.\n * Example: mode = 'xy', overScaleMode = 'y' -> it's means 'x' - works as before, and 'y' only works for one scale when cursor is under it.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param {string} mode - 'xy', 'x' or 'y'\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\n\n\nfunction getEnabledScalesByPoint(mode, point, chart) {\n  var scale = getScaleUnderPoint(point, chart);\n\n  if (scale && directionEnabled(mode, scale.axis, chart)) {\n    return [scale];\n  }\n\n  var enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (!directionEnabled(mode, scaleItem.axis, chart)) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nvar chartStates = new WeakMap();\n\nfunction getState(chart) {\n  var state = chartStates.get(chart);\n\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  var range = scale.max - scale.min;\n  var newRange = range * (zoom - 1);\n  var centerPoint = scale.isHorizontal() ? center.x : center.y; // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n\n  var minPercent = Math.max(0, Math.min(1, (scale.getValueForPixel(centerPoint) - scale.min) / range || 0));\n  var maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  var limit = scaleLimits[prop];\n\n  if (limit === 'original') {\n    var original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n\n  return valueOrDefault(limit, fallback);\n}\n\nfunction updateRange(scale, _ref2, limits) {\n  var min = _ref2.min,\n      max = _ref2.max;\n  var zoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var state = getState(scale.chart);\n  var id = scale.id,\n      axis = scale.axis,\n      scaleOpts = scale.options;\n  var scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  var _scaleLimits$minRange = scaleLimits.minRange,\n      minRange = _scaleLimits$minRange === void 0 ? 0 : _scaleLimits$minRange;\n  var minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  var maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  var cmin = Math.max(min, minLimit);\n  var cmax = Math.min(max, maxLimit);\n  var range = zoom ? Math.max(cmax - cmin, minRange) : scale.max - scale.min;\n\n  if (cmax - cmin !== range) {\n    if (minLimit > cmax - range) {\n      min = cmin;\n      max = cmin + range;\n    } else if (maxLimit < cmin + range) {\n      max = cmax;\n      min = cmax - range;\n    } else {\n      var offset = (range - cmax + cmin) / 2;\n      min = cmin - offset;\n      max = cmax + offset;\n    }\n  } else {\n    min = cmin;\n    max = cmax;\n  }\n\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n  state.updatedScaleLimits[scale.id] = {\n    min: min,\n    max: max\n  }; // return true if the scale range is changed\n\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  var delta = zoomDelta(scale, zoom, center);\n  var newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\n\nvar integerChange = function integerChange(v) {\n  return v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n};\n\nfunction existCategoryFromMaxZoom(scale) {\n  var labels = scale.getLabels();\n  var maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  var delta = zoomDelta(scale, zoom, center);\n\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n\n  var newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  var labels = scale.getLabels();\n  var lastLabelIndex = labels.length - 1;\n  var min = scale.min,\n      max = scale.max; // The visible range. Ticks can be skipped, and thus not reliable.\n\n  var range = Math.max(max - min, 1); // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n\n  var stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  var stepSize = Math.round(Math.abs(delta / stepDelta));\n  var applied;\n\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {\n    min: min,\n    max: max\n  }, limits) || applied;\n}\n\nvar OFFSETS = {\n  second: 500,\n  // 500 ms\n  minute: 30 * 1000,\n  // 30 s\n  hour: 30 * 60 * 1000,\n  // 30 m\n  day: 12 * 60 * 60 * 1000,\n  // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000,\n  // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n\n};\n\nfunction panNumericalScale(scale, delta, limits) {\n  var canZoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var prevStart = scale.min,\n      prevEnd = scale.max,\n      options = scale.options;\n  var round = options.time && options.time.round;\n  var offset = OFFSETS[round] || 0;\n  var newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  var newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n\n  var _ref3 = canZoom && limits && limits[scale.axis] || {},\n      _ref3$min = _ref3.min,\n      minLimit = _ref3$min === void 0 ? -Infinity : _ref3$min,\n      _ref3$max = _ref3.max,\n      maxLimit = _ref3$max === void 0 ? Infinity : _ref3$max;\n\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nvar zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale\n};\nvar panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  var id = scale.id,\n      _scale$options = scale.options,\n      min = _scale$options.min,\n      max = _scale$options.max;\n\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n\n  var previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\n\nfunction removeMissingScales(limits, scales) {\n  each(limits, function (opt, key) {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\n\nfunction storeOriginalScaleLimits(chart, state) {\n  var scales = chart.scales;\n  var originalScaleLimits = state.originalScaleLimits,\n      updatedScaleLimits = state.updatedScaleLimits;\n  each(scales, function (scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {\n          scale: scale.min,\n          options: scale.options.min\n        },\n        max: {\n          scale: scale.max,\n          options: scale.options.max\n        }\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  var fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction getCenter(chart) {\n  var ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\n\n\nfunction zoom(chart, amount) {\n  var transition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';\n\n  var _ref4 = typeof amount === 'number' ? {\n    x: amount,\n    y: amount\n  } : amount,\n      _ref4$x = _ref4.x,\n      x = _ref4$x === void 0 ? 1 : _ref4$x,\n      _ref4$y = _ref4.y,\n      y = _ref4$y === void 0 ? 1 : _ref4$y,\n      _ref4$focalPoint = _ref4.focalPoint,\n      focalPoint = _ref4$focalPoint === void 0 ? getCenter(chart) : _ref4$focalPoint;\n\n  var state = getState(chart);\n  var _state$options = state.options,\n      limits = _state$options.limits,\n      zoomOptions = _state$options.zoom;\n\n  var _ref5 = zoomOptions || {},\n      _ref5$mode = _ref5.mode,\n      mode = _ref5$mode === void 0 ? 'xy' : _ref5$mode,\n      overScaleMode = _ref5.overScaleMode;\n\n  storeOriginalScaleLimits(chart, state);\n  var xEnabled = x !== 1 && directionEnabled(mode, 'x', chart);\n  var yEnabled = y !== 1 && directionEnabled(mode, 'y', chart);\n  var enabledScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart: chart\n  }]);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  var v0 = scale.getValueForPixel(pixel0);\n  var v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction zoomRect(chart, p0, p1) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  var state = getState(chart);\n  var _state$options2 = state.options,\n      limits = _state$options2.limits,\n      zoomOptions = _state$options2.zoom;\n  var _zoomOptions$mode = zoomOptions.mode,\n      mode = _zoomOptions$mode === void 0 ? 'xy' : _zoomOptions$mode;\n  storeOriginalScaleLimits(chart, state);\n  var xEnabled = directionEnabled(mode, 'x', chart);\n  var yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      updateRange(scale, getRange(scale, p0.x, p1.x), limits, true);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      updateRange(scale, getRange(scale, p0.y, p1.y), limits, true);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart: chart\n  }]);\n}\n\nfunction zoomScale(chart, scaleId, range) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  storeOriginalScaleLimits(chart, getState(chart));\n  var scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\nfunction resetZoom(chart) {\n  var transition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n  var state = getState(chart);\n  var originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function (scale) {\n    var scaleOptions = scale.options;\n\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{\n    chart: chart\n  }]);\n}\n\nfunction getOriginalRange(state, scaleId) {\n  var original = state.originalScaleLimits[scaleId];\n\n  if (!original) {\n    return;\n  }\n\n  var min = original.min,\n      max = original.max;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\n\nfunction getZoomLevel(chart) {\n  var state = getState(chart);\n  var min = 1;\n  var max = 1;\n  each(chart.scales, function (scale) {\n    var origRange = getOriginalRange(state, scale.id);\n\n    if (origRange) {\n      var level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\n\nfunction panScale(scale, delta, limits, state) {\n  var panDelta = state.panDelta; // Add possible cumulative delta from previous pan attempts where scale did not change\n\n  var storedDelta = panDelta[scale.id] || 0;\n\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n\n  var fn = panFunctions[scale.type] || panFunctions.default;\n\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n\n  var _ref6 = typeof delta === 'number' ? {\n    x: delta,\n    y: delta\n  } : delta,\n      _ref6$x = _ref6.x,\n      x = _ref6$x === void 0 ? 0 : _ref6$x,\n      _ref6$y = _ref6.y,\n      y = _ref6$y === void 0 ? 0 : _ref6$y;\n\n  var state = getState(chart);\n  var _state$options3 = state.options,\n      panOptions = _state$options3.pan,\n      limits = _state$options3.limits;\n\n  var _ref7 = panOptions || {},\n      _ref7$mode = _ref7.mode,\n      mode = _ref7$mode === void 0 ? 'xy' : _ref7$mode,\n      onPan = _ref7.onPan;\n\n  storeOriginalScaleLimits(chart, state);\n  var xEnabled = x !== 0 && directionEnabled(mode, 'x', chart);\n  var yEnabled = y !== 0 && directionEnabled(mode, 'y', chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart: chart\n  }]);\n}\n\nfunction getInitialScaleBounds(chart) {\n  var state = getState(chart);\n  var scaleBounds = {};\n\n  for (var _i = 0, _Object$keys = Object.keys(chart.scales); _i < _Object$keys.length; _i++) {\n    var scaleId = _Object$keys[_i];\n\n    var _ref8 = state.originalScaleLimits[scaleId] || {\n      min: {},\n      max: {}\n    },\n        min = _ref8.min,\n        max = _ref8.max;\n\n    scaleBounds[scaleId] = {\n      min: min.scale,\n      max: max.scale\n    };\n  }\n\n  return scaleBounds;\n}\n\nfunction isZoomedOrPanned(chart) {\n  var scaleBounds = getInitialScaleBounds(chart);\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(chart.scales); _i2 < _Object$keys2.length; _i2++) {\n    var scaleId = _Object$keys2[_i2];\n    var _scaleBounds$scaleId = scaleBounds[scaleId],\n        originalMin = _scaleBounds$scaleId.min,\n        originalMax = _scaleBounds$scaleId.max;\n\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction removeHandler(chart, type) {\n  var _getState = getState(chart),\n      handlers = _getState.handlers;\n\n  var handler = handlers[type];\n\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  var _getState2 = getState(chart),\n      handlers = _getState2.handlers,\n      options = _getState2.options;\n\n  var oldHandler = handlers[type];\n\n  if (oldHandler && oldHandler.target === target) {\n    // already attached\n    return;\n  }\n\n  removeHandler(chart, type);\n\n  handlers[type] = function (event) {\n    return handler(chart, event, options);\n  };\n\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  var state = getState(chart);\n\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  var onZoomStart = zoomOptions.onZoomStart,\n      onZoomRejected = zoomOptions.onZoomRejected;\n\n  if (onZoomStart) {\n    var _event$target$getBoun = event.target.getBoundingClientRect(),\n        offsetX = _event$target$getBoun.left,\n        offsetY = _event$target$getBoun.top;\n\n    var point = {\n      x: event.clientX - offsetX,\n      y: event.clientY - offsetY\n    };\n\n    if (callback(onZoomStart, [{\n      chart: chart,\n      event: event,\n      point: point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart: chart,\n        event: event\n      }]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  var state = getState(chart);\n  var _state$options4 = state.options,\n      panOptions = _state$options4.pan,\n      _state$options4$zoom = _state$options4.zoom,\n      zoomOptions = _state$options4$zoom === void 0 ? {} : _state$options4$zoom;\n\n  if (keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart: chart,\n      event: event\n    }]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  state.dragStart = event;\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n}\n\nfunction computeDragRect(chart, mode, beginPoint, endPoint) {\n  var _beginPoint$target$ge = beginPoint.target.getBoundingClientRect(),\n      offsetX = _beginPoint$target$ge.left,\n      offsetY = _beginPoint$target$ge.top;\n\n  var xEnabled = directionEnabled(mode, 'x', chart);\n  var yEnabled = directionEnabled(mode, 'y', chart);\n  var _chart$chartArea = chart.chartArea,\n      top = _chart$chartArea.top,\n      left = _chart$chartArea.left,\n      right = _chart$chartArea.right,\n      bottom = _chart$chartArea.bottom,\n      chartWidth = _chart$chartArea.width,\n      chartHeight = _chart$chartArea.height;\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;\n    right = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.clientY, endPoint.clientY) - offsetY;\n    bottom = Math.max(beginPoint.clientY, endPoint.clientY) - offsetY;\n  }\n\n  var width = right - left;\n  var height = bottom - top;\n  return {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    width: width,\n    height: height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  var state = getState(chart);\n\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart, 'mousemove');\n  var _state$options$zoom = state.options.zoom,\n      mode = _state$options$zoom.mode,\n      onZoomComplete = _state$options$zoom.onZoomComplete,\n      _state$options$zoom$d = _state$options$zoom.drag.threshold,\n      threshold = _state$options$zoom$d === void 0 ? 0 : _state$options$zoom$d;\n  var rect = computeDragRect(chart, mode, state.dragStart, event);\n  var distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  var distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  var distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY); // Remove drag start and end before chart update to stop drawing selected area\n\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom');\n  setTimeout(function () {\n    return state.dragging = false;\n  }, 500);\n  callback(onZoomComplete, [{\n    chart: chart\n  }]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{\n      chart: chart,\n      event: event\n    }]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  } // Prevent the event from triggering the default behavior (eg. Content scrolling).\n\n\n  if (event.cancelable) {\n    event.preventDefault();\n  } // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n\n\n  if (event.deltaY === undefined) {\n    return;\n  }\n\n  return true;\n}\n\nfunction wheel(chart, event) {\n  var _getState3 = getState(chart),\n      onZoomComplete = _getState3.handlers.onZoomComplete,\n      zoomOptions = _getState3.options.zoom;\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  var rect = event.target.getBoundingClientRect();\n  var speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  var amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(function () {\n      return callback(handler, [{\n        chart: chart\n      }]);\n    }, delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  var canvas = chart.canvas;\n  var _options$zoom = options.zoom,\n      wheelOptions = _options$zoom.wheel,\n      dragOptions = _options$zoom.drag,\n      onZoomComplete = _options$zoom.onZoomComplete; // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n  }\n}\n\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n}\n\nfunction createEnabler(chart, state) {\n  return function (recognizer, event) {\n    var _state$options5 = state.options,\n        panOptions = _state$options5.pan,\n        _state$options5$zoom = _state$options5.zoom,\n        zoomOptions = _state$options5$zoom === void 0 ? {} : _state$options5$zoom;\n\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n\n    var srcEvent = event && event.srcEvent;\n\n    if (!srcEvent) {\n      // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n\n    if (!state.panning && event.pointerType === 'mouse' && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {\n      callback(panOptions.onPanRejected, [{\n        chart: chart,\n        event: event\n      }]);\n      return false;\n    }\n\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  var pinchX = Math.abs(p0.clientX - p1.clientX);\n  var pinchY = Math.abs(p0.clientY - p1.clientY); // diagonal fingers will change both (xy) axes\n\n  var p = pinchX / pinchY;\n  var x, y;\n\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    var center = e.center,\n        pointers = e.pointers; // Hammer reports the total scaling. We need the incremental amount\n\n    var zoomPercent = 1 / state.scale * e.scale;\n    var rect = e.target.getBoundingClientRect();\n    var pinch = pinchAxes(pointers[0], pointers[1]);\n    var mode = state.options.zoom.mode;\n    var amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount); // Keep track of overall scale\n\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n\n    callback(state.options.zoom.onZoomComplete, [{\n      chart: chart\n    }]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  var delta = state.delta;\n\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\n\nfunction startPan(chart, state, event) {\n  var _state$options$pan = state.options.pan,\n      enabled = _state$options$pan.enabled,\n      overScaleMode = _state$options$pan.overScaleMode,\n      onPanStart = _state$options$pan.onPanStart,\n      onPanRejected = _state$options$pan.onPanRejected;\n\n  if (!enabled) {\n    return;\n  }\n\n  var rect = event.target.getBoundingClientRect();\n  var point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{\n    chart: chart,\n    event: event,\n    point: point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart: chart,\n      event: event\n    }]);\n  }\n\n  state.panScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(function () {\n      return state.panning = false;\n    }, 500);\n    callback(state.options.pan.onPanComplete, [{\n      chart: chart\n    }]);\n  }\n}\n\nvar hammers = new WeakMap();\n\nfunction startHammer(chart, options) {\n  var state = getState(chart);\n  var canvas = chart.canvas;\n  var panOptions = options.pan,\n      zoomOptions = options.zoom;\n  var mc = new Hammer.Manager(canvas);\n\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', function () {\n      return startPinch(chart, state);\n    });\n    mc.on('pinch', function (e) {\n      return handlePinch(chart, state, e);\n    });\n    mc.on('pinchend', function (e) {\n      return endPinch(chart, state, e);\n    });\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', function (e) {\n      return startPan(chart, state, e);\n    });\n    mc.on('panmove', function (e) {\n      return handlePan(chart, state, e);\n    });\n    mc.on('panend', function () {\n      return endPan(chart, state);\n    });\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  var mc = hammers.get(chart);\n\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"1.2.1\";\nvar plugin = {\n  id: 'zoom',\n  version: version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function start(chart, _args, options) {\n    var state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = function (delta, panScales, transition) {\n      return pan(chart, delta, panScales, transition);\n    };\n\n    chart.zoom = function (args, transition) {\n      return zoom(chart, args, transition);\n    };\n\n    chart.zoomScale = function (id, range, transition) {\n      return zoomScale(chart, id, range, transition);\n    };\n\n    chart.resetZoom = function (transition) {\n      return resetZoom(chart, transition);\n    };\n\n    chart.getZoomLevel = function () {\n      return getZoomLevel(chart);\n    };\n\n    chart.getInitialScaleBounds = function () {\n      return getInitialScaleBounds(chart);\n    };\n\n    chart.isZoomedOrPanned = function () {\n      return isZoomedOrPanned(chart);\n    };\n  },\n  beforeEvent: function beforeEvent(chart) {\n    var state = getState(chart);\n\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n  beforeUpdate: function beforeUpdate(chart, args, options) {\n    var state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw: function beforeDatasetsDraw(chart, args, options) {\n    var _getState4 = getState(chart),\n        dragStart = _getState4.dragStart,\n        dragEnd = _getState4.dragEnd;\n\n    if (dragEnd) {\n      var _computeDragRect = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd),\n          left = _computeDragRect.left,\n          top = _computeDragRect.top,\n          width = _computeDragRect.width,\n          height = _computeDragRect.height;\n\n      var dragOptions = options.zoom.drag;\n      var ctx = chart.ctx;\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n      ctx.fillRect(left, top, width, height);\n\n      if (dragOptions.borderWidth > 0) {\n        ctx.lineWidth = dragOptions.borderWidth;\n        ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n        ctx.strokeRect(left, top, width, height);\n      }\n\n      ctx.restore();\n    }\n  },\n  stop: function stop(chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n\n    removeState(chart);\n  },\n  panFunctions: panFunctions,\n  zoomFunctions: zoomFunctions\n};\nexport { plugin as default, pan, resetZoom, zoom, zoomScale };","map":null,"metadata":{},"sourceType":"module"}