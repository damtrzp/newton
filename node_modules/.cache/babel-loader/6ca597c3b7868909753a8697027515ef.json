{"ast":null,"code":"import _toConsumableArray from \"/home/programowanie/newton-rhapson/newton/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/home/programowanie/newton-rhapson/newton/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"/home/programowanie/newton-rhapson/newton/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/programowanie/newton-rhapson/newton/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/programowanie/newton-rhapson/newton/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/programowanie/newton-rhapson/newton/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/programowanie/newton-rhapson/newton/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*!\n* chartjs-plugin-annotation v1.4.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2022 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, defaults, Animations, Chart } from 'chart.js';\nimport { defined, distanceBetweenPoints, callback, isFinite, valueOrDefault, isObject, toRadians, toFont, isArray, addRoundedRectPath, toTRBLCorners, toPadding, PI, drawPoint, RAD_PER_DEG, clipArea, unclipArea } from 'chart.js/helpers';\nvar clickHooks = ['click', 'dblclick'];\nvar moveHooks = ['enter', 'leave'];\nvar hooks = clickHooks.concat(moveHooks);\n\nfunction updateListeners(chart, state, options) {\n  state.listened = false;\n  state.moveListened = false;\n  hooks.forEach(function (hook) {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    } else if (defined(state.listeners[hook])) {\n      delete state.listeners[hook];\n    }\n  });\n  moveHooks.forEach(function (hook) {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(function (scope) {\n      if (!state.listened) {\n        clickHooks.forEach(function (hook) {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n          }\n        });\n      }\n\n      if (!state.moveListened) {\n        moveHooks.forEach(function (hook) {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        handleMoveEvents(state, event);\n        break;\n\n      case 'click':\n        handleClickEvents(state, event, options);\n        break;\n    }\n  }\n}\n\nfunction handleMoveEvents(state, event) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  var element;\n\n  if (event.type === 'mousemove') {\n    element = getNearestItem(state.elements, event);\n  }\n\n  var previous = state.hovered;\n  state.hovered = element;\n  dispatchMoveEvents(state, {\n    previous: previous,\n    element: element\n  }, event);\n}\n\nfunction dispatchMoveEvents(state, elements, event) {\n  var previous = elements.previous,\n      element = elements.element;\n\n  if (previous && previous !== element) {\n    dispatchEvent(previous.options.leave || state.listeners.leave, previous, event);\n  }\n\n  if (element && element !== previous) {\n    dispatchEvent(element.options.enter || state.listeners.enter, element, event);\n  }\n}\n\nfunction handleClickEvents(state, event, options) {\n  var listeners = state.listeners;\n  var element = getNearestItem(state.elements, event);\n\n  if (element) {\n    var elOpts = element.options;\n    var dblclick = elOpts.dblclick || listeners.dblclick;\n    var click = elOpts.click || listeners.click;\n\n    if (element.clickTimeout) {\n      // 2nd click before timeout, so its a double click\n      clearTimeout(element.clickTimeout);\n      delete element.clickTimeout;\n      dispatchEvent(dblclick, element, event);\n    } else if (dblclick) {\n      // if there is a dblclick handler, wait for dblClickSpeed ms before deciding its a click\n      element.clickTimeout = setTimeout(function () {\n        delete element.clickTimeout;\n        dispatchEvent(click, element, event);\n      }, options.dblClickSpeed);\n    } else {\n      // no double click handler, just call the click handler directly\n      dispatchEvent(click, element, event);\n    }\n  }\n}\n\nfunction dispatchEvent(handler, element, event) {\n  callback(handler, [element.$context, event]);\n}\n\nfunction getNearestItem(elements, position) {\n  var minDistance = Number.POSITIVE_INFINITY;\n  return elements.filter(function (element) {\n    return element.options.display && element.inRange(position.x, position.y);\n  }).reduce(function (nearestItems, element) {\n    var center = element.getCenterPoint();\n    var distance = distanceBetweenPoints(position, center);\n\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n\n    return nearestItems;\n  }, []).sort(function (a, b) {\n    return a._index - b._index;\n  }).slice(0, 1)[0]; // return only the top item\n}\n\nfunction adjustScaleRange(chart, scale, annotations) {\n  var range = getScaleLimits(scale, annotations);\n  var changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\nfunction verifyScaleOptions(annotations, scales) {\n  var _iterator = _createForOfIteratorHelper(annotations),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _annotation = _step.value;\n      verifyScaleIDs(_annotation, scales);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    var changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\n\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\n\nfunction verifyScaleIDs(annotation, scales) {\n  for (var _i = 0, _arr = ['scaleID', 'xScaleID', 'yScaleID']; _i < _arr.length; _i++) {\n    var key = _arr[_i];\n\n    if (annotation[key] && !scales[annotation[key]] && verifyProperties(annotation, key)) {\n      console.warn(\"No scale found with id '\".concat(annotation[key], \"' for annotation '\").concat(annotation.id, \"'\"));\n    }\n  }\n}\n\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n\n  var axis = key.charAt(0);\n\n  for (var _i2 = 0, _arr2 = ['Min', 'Max', 'Value']; _i2 < _arr2.length; _i2++) {\n    var prop = _arr2[_i2];\n\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getScaleLimits(scale, annotations) {\n  var axis = scale.axis;\n  var scaleID = scale.id;\n  var scaleIDOption = axis + 'ScaleID';\n  var limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n\n  var _iterator2 = _createForOfIteratorHelper(annotations),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _annotation2 = _step2.value;\n\n      if (_annotation2.scaleID === scaleID) {\n        updateLimits(_annotation2, scale, ['value', 'endValue'], limits);\n      } else if (_annotation2[scaleIDOption] === scaleID) {\n        updateLimits(_annotation2, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return limits;\n}\n\nfunction updateLimits(annotation, scale, props, limits) {\n  var _iterator3 = _createForOfIteratorHelper(props),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var prop = _step3.value;\n      var raw = annotation[prop];\n\n      if (defined(raw)) {\n        var value = scale.parse(raw);\n        limits.min = Math.min(limits.min, value);\n        limits.max = Math.max(limits.max, value);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n\nvar EPSILON = 0.001;\n\nvar clamp = function clamp(x, from, to) {\n  return Math.min(to, Math.max(from, x));\n};\n\nfunction clampAll(obj, from, to) {\n  for (var _i3 = 0, _Object$keys = Object.keys(obj); _i3 < _Object$keys.length; _i3++) {\n    var key = _Object$keys[_i3];\n    obj[key] = clamp(obj[key], from, to);\n  }\n\n  return obj;\n}\n\nfunction inPointRange(point, center, radius, borderWidth) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n\n  var hBorderWidth = borderWidth / 2 || 0;\n  return Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius + hBorderWidth, 2);\n}\n\nfunction inBoxRange(mouseX, mouseY, _ref, borderWidth) {\n  var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height;\n  var hBorderWidth = borderWidth / 2;\n  return mouseX >= x - hBorderWidth - EPSILON && mouseX <= x + width + hBorderWidth + EPSILON && mouseY >= y - hBorderWidth - EPSILON && mouseY <= y + height + hBorderWidth + EPSILON;\n}\n\nfunction getElementCenterPoint(element, useFinalPosition) {\n  var _element$getProps = element.getProps(['x', 'y'], useFinalPosition),\n      x = _element$getProps.x,\n      y = _element$getProps.y;\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nvar isOlderPart = function isOlderPart(act, req) {\n  return req > act || act.length > req.length && act.substr(0, req.length) === req;\n};\n\nfunction requireVersion(pkg, min, ver) {\n  var strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var parts = ver.split('.');\n  var i = 0;\n\n  var _iterator4 = _createForOfIteratorHelper(min.split('.')),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var req = _step4.value;\n      var act = parts[i++];\n\n      if (parseInt(req, 10) < parseInt(act, 10)) {\n        break;\n      }\n\n      if (isOlderPart(act, req)) {\n        if (strict) {\n          throw new Error(\"\".concat(pkg, \" v\").concat(ver, \" is not supported. v\").concat(min, \" or newer is required.\"));\n        } else {\n          return false;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return true;\n}\n\nvar isPercentString = function isPercentString(s) {\n  return typeof s === 'string' && s.endsWith('%');\n};\n\nvar toPercent = function toPercent(s) {\n  return clamp(parseFloat(s) / 100, 0, 1);\n};\n\nfunction getRelativePosition(size, positionOption) {\n  if (positionOption === 'start') {\n    return 0;\n  }\n\n  if (positionOption === 'end') {\n    return size;\n  }\n\n  if (isPercentString(positionOption)) {\n    return toPercent(positionOption) * size;\n  }\n\n  return size / 2;\n}\n\nfunction getSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return toPercent(value) * size;\n  }\n\n  return size;\n}\n\nfunction calculateTextAlignment(size, options) {\n  var x = size.x,\n      width = size.width;\n  var textAlign = options.textAlign;\n\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n\n  return x;\n}\n\nfunction toPosition(value) {\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, 'center'),\n      y: valueOrDefault(value.y, 'center')\n    };\n  }\n\n  value = valueOrDefault(value, 'center');\n  return {\n    x: value,\n    y: value\n  };\n}\n\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\n\nvar widthCache = new Map();\n/**\n * Determine if content is an image or a canvas.\n * @param {*} content\n * @returns boolean|undefined\n * @todo move this function to chart.js helpers\n */\n\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    var type = content.toString();\n    return type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]';\n  }\n}\n/**\n * Set the translation on the canvas if the rotation must be applied.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Element} element - annotation element to use for applying the translation\n * @param {number} rotation - rotation (in degrees) to apply\n */\n\n\nfunction translate(ctx, element, rotation) {\n  if (rotation) {\n    var center = element.getCenterPoint();\n    ctx.translate(center.x, center.y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-center.x, -center.y);\n  }\n}\n/**\n * Apply border options to the canvas context before drawing a shape\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Object} options - options with border configuration\n * @returns {boolean} true is the border options have been applied\n */\n\n\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n/**\n * Apply shadow options to the canvas context before drawing a shape\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Object} options - options with shadow configuration\n */\n\n\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n/**\n * Measure the label size using the label options.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Object} options - options to configure the label\n * @returns {{width: number, height: number}} the measured size of the label\n */\n\n\nfunction measureLabelSize(ctx, options) {\n  var content = options.content;\n\n  if (isImageOrCanvas(content)) {\n    return {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n  }\n\n  var font = toFont(options.font);\n  var strokeWidth = options.textStrokeWidth;\n  var lines = isArray(content) ? content : [content];\n  var mapKey = lines.join() + font.string + strokeWidth + (ctx._measureText ? '-spriting' : '');\n\n  if (!widthCache.has(mapKey)) {\n    ctx.save();\n    ctx.font = font.string;\n    var count = lines.length;\n    var width = 0;\n\n    for (var i = 0; i < count; i++) {\n      var text = lines[i];\n      width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    }\n\n    ctx.restore();\n    var height = count * font.lineHeight + strokeWidth;\n    widthCache.set(mapKey, {\n      width: width,\n      height: height\n    });\n  }\n\n  return widthCache.get(mapKey);\n}\n/**\n * Draw a box with the size and the styling options.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {{x: number, y: number, width: number, height: number}} rect - rect to draw\n * @param {Object} options - options to style the box\n * @returns {undefined}\n */\n\n\nfunction drawBox(ctx, rect, options) {\n  var x = rect.x,\n      y = rect.y,\n      width = rect.width,\n      height = rect.height;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  var stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x: x,\n    y: y,\n    w: width,\n    h: height,\n    // TODO: v2 remove support for cornerRadius\n    radius: clampAll(toTRBLCorners(valueOrDefault(options.cornerRadius, options.borderRadius)), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n\n  ctx.restore();\n}\n/**\n * Draw a label with the size and the styling options.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {{x: number, y: number, width: number, height: number}} rect - rect to map teh label\n * @param {Object} options - options to style the label\n * @returns {undefined}\n */\n\n\nfunction _drawLabel(ctx, rect, options) {\n  var content = options.content;\n\n  if (isImageOrCanvas(content)) {\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    return;\n  }\n\n  var labels = isArray(content) ? content : [content];\n  var font = toFont(options.font);\n  var lh = font.lineHeight;\n  var x = calculateTextAlignment(rect, options);\n  var y = rect.y + lh / 2 + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.font = font.string;\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n\n  if (setTextStrokeStyle(ctx, options)) {\n    labels.forEach(function (l, i) {\n      return ctx.strokeText(l, x, y + i * lh);\n    });\n  }\n\n  ctx.fillStyle = options.color;\n  labels.forEach(function (l, i) {\n    return ctx.fillText(l, x, y + i * lh);\n  });\n  ctx.restore();\n}\n\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n/**\n * @typedef {import('chart.js').Point} Point\n */\n\n/**\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @returns {Point}\n */\n\n\nfunction getRectCenterPoint(rect) {\n  var x = rect.x,\n      y = rect.y,\n      width = rect.width,\n      height = rect.height;\n  return {\n    x: x + width / 2,\n    y: y + height / 2\n  };\n}\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {Point} point - the point to rotate\n * @param {Point} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {Point} rotated point\n */\n\n\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import(\"chart.js\").Point } Point\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n */\n\n/**\n * @param {Scale} scale\n * @param {number|string} value\n * @param {number} fallback\n * @returns {number}\n */\n\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n/**\n * @param {Scale} scale\n * @param {{start: number, end: number}} options\n * @returns {{start: number, end: number}}\n */\n\n\nfunction getChartDimensionByScale(scale, options) {\n  if (scale) {\n    var min = scaleValue(scale, options.min, options.start);\n    var max = scaleValue(scale, options.max, options.end);\n    return {\n      start: Math.min(min, max),\n      end: Math.max(min, max)\n    };\n  }\n\n  return {\n    start: options.start,\n    end: options.end\n  };\n}\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {Point}\n */\n\n\nfunction getChartPoint(chart, options) {\n  var chartArea = chart.chartArea,\n      scales = chart.scales;\n  var xScale = scales[options.xScaleID];\n  var yScale = scales[options.yScaleID];\n  var x = chartArea.width / 2;\n  var y = chartArea.height / 2;\n\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, x);\n  }\n\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, y);\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {{x?:number, y?: number, x2?: number, y2?: number, width?: number, height?: number}}\n */\n\n\nfunction getChartRect(chart, options) {\n  var xScale = chart.scales[options.xScaleID];\n  var yScale = chart.scales[options.yScaleID];\n  var _chart$chartArea = chart.chartArea,\n      y = _chart$chartArea.top,\n      x = _chart$chartArea.left,\n      y2 = _chart$chartArea.bottom,\n      x2 = _chart$chartArea.right;\n\n  if (!xScale && !yScale) {\n    return {};\n  }\n\n  var xDim = getChartDimensionByScale(xScale, {\n    min: options.xMin,\n    max: options.xMax,\n    start: x,\n    end: x2\n  });\n  x = xDim.start;\n  x2 = xDim.end;\n  var yDim = getChartDimensionByScale(yScale, {\n    min: options.yMin,\n    max: options.yMax,\n    start: y,\n    end: y2\n  });\n  y = yDim.start;\n  y2 = yDim.end;\n  return {\n    x: x,\n    y: y,\n    x2: x2,\n    y2: y2,\n    width: x2 - x,\n    height: y2 - y\n  };\n}\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions} options\n */\n\n\nfunction getChartCircle(chart, options) {\n  var point = getChartPoint(chart, options);\n  return {\n    x: point.x + options.xAdjust,\n    y: point.y + options.yAdjust,\n    width: options.radius * 2,\n    height: options.radius * 2\n  };\n}\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions} options\n * @returns\n */\n\n\nfunction resolvePointPosition(chart, options) {\n  if (!isBoundToPoint(options)) {\n    var box = getChartRect(chart, options);\n    var point = getRectCenterPoint(box);\n    var radius = options.radius;\n\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n\n    return {\n      x: point.x + options.xAdjust,\n      y: point.y + options.yAdjust,\n      width: radius * 2,\n      height: radius * 2\n    };\n  }\n\n  return getChartCircle(chart, options);\n}\n\nvar BoxAnnotation = /*#__PURE__*/function (_Element) {\n  _inherits(BoxAnnotation, _Element);\n\n  function BoxAnnotation() {\n    _classCallCheck(this, BoxAnnotation);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BoxAnnotation).apply(this, arguments));\n  }\n\n  _createClass(BoxAnnotation, [{\n    key: \"inRange\",\n    value: function inRange(mouseX, mouseY, useFinalPosition) {\n      var _rotated = rotated({\n        x: mouseX,\n        y: mouseY\n      }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation)),\n          x = _rotated.x,\n          y = _rotated.y;\n\n      return inBoxRange(x, y, this.getProps(['x', 'y', 'width', 'height'], useFinalPosition), this.options.borderWidth);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(useFinalPosition) {\n      return getRectCenterPoint(this.getProps(['x', 'y', 'width', 'height'], useFinalPosition));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      ctx.save();\n      translate(ctx, this, this.options.rotation);\n      drawBox(ctx, this, this.options);\n      ctx.restore();\n    }\n  }, {\n    key: \"drawLabel\",\n    value: function drawLabel(ctx) {\n      var x = this.x,\n          y = this.y,\n          width = this.width,\n          height = this.height,\n          options = this.options;\n      var label = options.label,\n          borderWidth = options.borderWidth;\n      var halfBorder = borderWidth / 2;\n      var position = toPosition(label.position);\n      var padding = toPadding(label.padding);\n      var labelSize = measureLabelSize(ctx, label);\n      var labelRect = {\n        x: calculateX(this, labelSize, position, padding),\n        y: calculateY(this, labelSize, position, padding),\n        width: labelSize.width,\n        height: labelSize.height\n      };\n      ctx.save();\n      translate(ctx, this, label.rotation);\n      ctx.beginPath();\n      ctx.rect(x + halfBorder + padding.left, y + halfBorder + padding.top, width - borderWidth - padding.width, height - borderWidth - padding.height);\n      ctx.clip();\n\n      _drawLabel(ctx, labelRect, label);\n\n      ctx.restore();\n    }\n  }, {\n    key: \"resolveElementProperties\",\n    value: function resolveElementProperties(chart, options) {\n      return getChartRect(chart, options);\n    }\n  }]);\n\n  return BoxAnnotation;\n}(Element);\n\nBoxAnnotation.id = 'boxAnnotation';\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  cornerRadius: undefined,\n  // TODO: v2 remove support for cornerRadius\n  display: true,\n  label: {\n    borderWidth: undefined,\n    color: 'black',\n    content: null,\n    drawTime: undefined,\n    enabled: false,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    xAdjust: 0,\n    yAdjust: 0,\n    width: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y'\n};\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nfunction calculateX(box, labelSize, position, padding) {\n  var start = box.x,\n      end = box.x2,\n      size = box.width,\n      options = box.options;\n  var _options$label = options.label,\n      adjust = _options$label.xAdjust,\n      borderWidth = _options$label.borderWidth;\n  return calculatePosition$1({\n    start: start,\n    end: end,\n    size: size\n  }, {\n    position: position.x,\n    padding: {\n      start: padding.left,\n      end: padding.right\n    },\n    adjust: adjust,\n    borderWidth: borderWidth,\n    size: labelSize.width\n  });\n}\n\nfunction calculateY(box, labelSize, position, padding) {\n  var start = box.y,\n      end = box.y2,\n      size = box.height,\n      options = box.options;\n  var _options$label2 = options.label,\n      adjust = _options$label2.yAdjust,\n      borderWidth = _options$label2.borderWidth;\n  return calculatePosition$1({\n    start: start,\n    end: end,\n    size: size\n  }, {\n    position: position.y,\n    padding: {\n      start: padding.top,\n      end: padding.bottom\n    },\n    adjust: adjust,\n    borderWidth: borderWidth,\n    size: labelSize.height\n  });\n}\n\nfunction calculatePosition$1(boxOpts, labelOpts) {\n  var start = boxOpts.start,\n      end = boxOpts.end;\n  var position = labelOpts.position,\n      _labelOpts$padding = labelOpts.padding,\n      padStart = _labelOpts$padding.start,\n      padEnd = _labelOpts$padding.end,\n      adjust = labelOpts.adjust,\n      borderWidth = labelOpts.borderWidth;\n  var availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + padStart + getRelativePosition(availableSize, position);\n}\n\nvar pointInLine = function pointInLine(p1, p2, t) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n};\n\nvar interpolateX = function interpolateX(y, p1, p2) {\n  return pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\n};\n\nvar interpolateY = function interpolateY(x, p1, p2) {\n  return pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\n};\n\nvar sqr = function sqr(v) {\n  return v * v;\n};\n\nvar defaultEpsilon = 0.001;\n\nfunction isLineInArea(_ref2, _ref3) {\n  var x = _ref2.x,\n      y = _ref2.y,\n      x2 = _ref2.x2,\n      y2 = _ref2.y2;\n  var top = _ref3.top,\n      right = _ref3.right,\n      bottom = _ref3.bottom,\n      left = _ref3.left;\n  return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);\n}\n\nfunction limitPointToArea(_ref4, p2, _ref5) {\n  var x = _ref4.x,\n      y = _ref4.y;\n  var top = _ref5.top,\n      right = _ref5.right,\n      bottom = _ref5.bottom,\n      left = _ref5.left;\n\n  if (x < left) {\n    y = interpolateY(left, {\n      x: x,\n      y: y\n    }, p2);\n    x = left;\n  }\n\n  if (x > right) {\n    y = interpolateY(right, {\n      x: x,\n      y: y\n    }, p2);\n    x = right;\n  }\n\n  if (y < top) {\n    x = interpolateX(top, {\n      x: x,\n      y: y\n    }, p2);\n    y = top;\n  }\n\n  if (y > bottom) {\n    x = interpolateX(bottom, {\n      x: x,\n      y: y\n    }, p2);\n    y = bottom;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  var _limitPointToArea = limitPointToArea(p1, p2, area),\n      x = _limitPointToArea.x,\n      y = _limitPointToArea.y;\n\n  var _limitPointToArea2 = limitPointToArea(p2, p1, area),\n      x2 = _limitPointToArea2.x,\n      y2 = _limitPointToArea2.y;\n\n  return {\n    x: x,\n    y: y,\n    x2: x2,\n    y2: y2,\n    width: Math.abs(x2 - x),\n    height: Math.abs(y2 - y)\n  };\n}\n\nvar LineAnnotation = /*#__PURE__*/function (_Element2) {\n  _inherits(LineAnnotation, _Element2);\n\n  function LineAnnotation() {\n    _classCallCheck(this, LineAnnotation);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LineAnnotation).apply(this, arguments));\n  }\n\n  _createClass(LineAnnotation, [{\n    key: \"intersects\",\n    // TODO: make private in v2\n    value: function intersects(x, y) {\n      var epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultEpsilon;\n      var useFinalPosition = arguments.length > 3 ? arguments[3] : undefined;\n\n      // Adapted from https://stackoverflow.com/a/6853926/25507\n      var _this$getProps = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition),\n          x1 = _this$getProps.x,\n          y1 = _this$getProps.y,\n          x2 = _this$getProps.x2,\n          y2 = _this$getProps.y2;\n\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var lenSq = sqr(dx) + sqr(dy);\n      var t = lenSq === 0 ? -1 : ((x - x1) * dx + (y - y1) * dy) / lenSq;\n      var xx, yy;\n\n      if (t < 0) {\n        xx = x1;\n        yy = y1;\n      } else if (t > 1) {\n        xx = x2;\n        yy = y2;\n      } else {\n        xx = x1 + t * dx;\n        yy = y1 + t * dy;\n      }\n\n      return sqr(x - xx) + sqr(y - yy) <= epsilon;\n    }\n    /**\n     * @todo make private in v2\n     * @param {boolean} useFinalPosition - use the element's animation target instead of current position\n     * @param {top, right, bottom, left} [chartArea] - optional, area of the chart\n     * @returns {boolean} true if the label is visible\n     */\n\n  }, {\n    key: \"labelIsVisible\",\n    value: function labelIsVisible(useFinalPosition, chartArea) {\n      var labelOpts = this.options.label;\n\n      if (!labelOpts || !labelOpts.enabled) {\n        return false;\n      }\n\n      return !chartArea || isLineInArea(this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), chartArea);\n    } // TODO: make private in v2\n\n  }, {\n    key: \"isOnLabel\",\n    value: function isOnLabel(mouseX, mouseY, useFinalPosition) {\n      if (!this.labelIsVisible(useFinalPosition)) {\n        return false;\n      }\n\n      var _this$getProps2 = this.getProps(['labelX', 'labelY', 'labelWidth', 'labelHeight', 'labelRotation'], useFinalPosition),\n          labelX = _this$getProps2.labelX,\n          labelY = _this$getProps2.labelY,\n          labelWidth = _this$getProps2.labelWidth,\n          labelHeight = _this$getProps2.labelHeight,\n          labelRotation = _this$getProps2.labelRotation;\n\n      var _rotated2 = rotated({\n        x: mouseX,\n        y: mouseY\n      }, {\n        x: labelX,\n        y: labelY\n      }, -labelRotation),\n          x = _rotated2.x,\n          y = _rotated2.y;\n\n      var hBorderWidth = this.options.label.borderWidth / 2 || 0;\n      var w2 = labelWidth / 2 + hBorderWidth;\n      var h2 = labelHeight / 2 + hBorderWidth;\n      return x >= labelX - w2 - defaultEpsilon && x <= labelX + w2 + defaultEpsilon && y >= labelY - h2 - defaultEpsilon && y <= labelY + h2 + defaultEpsilon;\n    }\n  }, {\n    key: \"inRange\",\n    value: function inRange(mouseX, mouseY, useFinalPosition) {\n      var epsilon = sqr(this.options.borderWidth / 2);\n      return this.intersects(mouseX, mouseY, epsilon, useFinalPosition) || this.isOnLabel(mouseX, mouseY, useFinalPosition);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint() {\n      return {\n        x: (this.x2 + this.x) / 2,\n        y: (this.y2 + this.y) / 2\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var x = this.x,\n          y = this.y,\n          x2 = this.x2,\n          y2 = this.y2,\n          options = this.options;\n      ctx.save();\n\n      if (!setBorderStyle(ctx, options)) {\n        // no border width, then line is not drawn\n        return ctx.restore();\n      }\n\n      setShadowStyle(ctx, options);\n      var angle = Math.atan2(y2 - y, x2 - x);\n      var length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n\n      var _getArrowHeads = getArrowHeads(this),\n          startOpts = _getArrowHeads.startOpts,\n          endOpts = _getArrowHeads.endOpts,\n          startAdjust = _getArrowHeads.startAdjust,\n          endAdjust = _getArrowHeads.endAdjust;\n\n      ctx.translate(x, y);\n      ctx.rotate(angle);\n      ctx.beginPath();\n      ctx.moveTo(0 + startAdjust, 0);\n      ctx.lineTo(length - endAdjust, 0);\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n      drawArrowHead(ctx, 0, startAdjust, startOpts);\n      drawArrowHead(ctx, length, -endAdjust, endOpts);\n      ctx.restore();\n    }\n  }, {\n    key: \"drawLabel\",\n    value: function drawLabel(ctx, chartArea) {\n      if (!this.labelIsVisible(false, chartArea)) {\n        return;\n      }\n\n      var labelX = this.labelX,\n          labelY = this.labelY,\n          labelWidth = this.labelWidth,\n          labelHeight = this.labelHeight,\n          labelRotation = this.labelRotation,\n          labelPadding = this.labelPadding,\n          labelTextSize = this.labelTextSize,\n          label = this.options.label;\n      ctx.save();\n      ctx.translate(labelX, labelY);\n      ctx.rotate(labelRotation);\n      var boxRect = {\n        x: -(labelWidth / 2),\n        y: -(labelHeight / 2),\n        width: labelWidth,\n        height: labelHeight\n      };\n      drawBox(ctx, boxRect, label);\n      var labelTextRect = {\n        x: -(labelWidth / 2) + labelPadding.left + label.borderWidth / 2,\n        y: -(labelHeight / 2) + labelPadding.top + label.borderWidth / 2,\n        width: labelTextSize.width,\n        height: labelTextSize.height\n      };\n\n      _drawLabel(ctx, labelTextRect, label);\n\n      ctx.restore();\n    }\n  }, {\n    key: \"resolveElementProperties\",\n    value: function resolveElementProperties(chart, options) {\n      var scale = chart.scales[options.scaleID];\n      var _chart$chartArea2 = chart.chartArea,\n          y = _chart$chartArea2.top,\n          x = _chart$chartArea2.left,\n          y2 = _chart$chartArea2.bottom,\n          x2 = _chart$chartArea2.right;\n      var min, max;\n\n      if (scale) {\n        min = scaleValue(scale, options.value, NaN);\n        max = scaleValue(scale, options.endValue, min);\n\n        if (scale.isHorizontal()) {\n          x = min;\n          x2 = max;\n        } else {\n          y = min;\n          y2 = max;\n        }\n      } else {\n        var xScale = chart.scales[options.xScaleID];\n        var yScale = chart.scales[options.yScaleID];\n\n        if (xScale) {\n          x = scaleValue(xScale, options.xMin, x);\n          x2 = scaleValue(xScale, options.xMax, x2);\n        }\n\n        if (yScale) {\n          y = scaleValue(yScale, options.yMin, y);\n          y2 = scaleValue(yScale, options.yMax, y2);\n        }\n      }\n\n      var inside = isLineInArea({\n        x: x,\n        y: y,\n        x2: x2,\n        y2: y2\n      }, chart.chartArea);\n      var properties = inside ? limitLineToArea({\n        x: x,\n        y: y\n      }, {\n        x: x2,\n        y: y2\n      }, chart.chartArea) : {\n        x: x,\n        y: y,\n        x2: x2,\n        y2: y2,\n        width: Math.abs(x2 - x),\n        height: Math.abs(y2 - y)\n      };\n      var label = options.label;\n\n      if (label && label.content) {\n        return loadLabelRect(properties, chart, label);\n      }\n\n      return properties;\n    }\n  }]);\n\n  return LineAnnotation;\n}(Element);\n\nLineAnnotation.id = 'lineAnnotation';\nvar arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  enabled: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    enabled: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  display: true,\n  endValue: undefined,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    color: '#fff',\n    content: null,\n    cornerRadius: undefined,\n    // TODO: v2 remove support for cornerRadius\n    drawTime: undefined,\n    enabled: false,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    xPadding: undefined,\n    // TODO: v2 remove support for xPadding\n    yAdjust: 0,\n    yPadding: undefined // TODO: v2 remove support for yPadding\n\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y'\n};\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction loadLabelRect(line, chart, options) {\n  // TODO: v2 remove support for xPadding and yPadding\n  var lblPadding = options.padding,\n      xPadding = options.xPadding,\n      yPadding = options.yPadding,\n      borderWidth = options.borderWidth;\n  var padding = getPadding(lblPadding, xPadding, yPadding);\n  var textSize = measureLabelSize(chart.ctx, options);\n  var width = textSize.width + padding.width + borderWidth;\n  var height = textSize.height + padding.height + borderWidth;\n  var labelRect = calculateLabelPosition(line, options, {\n    width: width,\n    height: height,\n    padding: padding\n  }, chart.chartArea);\n  line.labelX = labelRect.x;\n  line.labelY = labelRect.y;\n  line.labelWidth = labelRect.width;\n  line.labelHeight = labelRect.height;\n  line.labelRotation = labelRect.rotation;\n  line.labelPadding = padding;\n  line.labelTextSize = textSize;\n  return line;\n}\n\nfunction calculateAutoRotation(line) {\n  var x = line.x,\n      y = line.y,\n      x2 = line.x2,\n      y2 = line.y2;\n  var rotation = Math.atan2(y2 - y, x2 - x); // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n} // TODO: v2 remove support for xPadding and yPadding\n\n\nfunction getPadding(padding, xPadding, yPadding) {\n  var tempPadding = padding;\n\n  if (xPadding || yPadding) {\n    tempPadding = {\n      x: xPadding || 6,\n      y: yPadding || 6\n    };\n  }\n\n  return toPadding(tempPadding);\n}\n\nfunction calculateLabelPosition(line, label, sizes, chartArea) {\n  var width = sizes.width,\n      height = sizes.height,\n      padding = sizes.padding;\n  var xAdjust = label.xAdjust,\n      yAdjust = label.yAdjust;\n  var p1 = {\n    x: line.x,\n    y: line.y\n  };\n  var p2 = {\n    x: line.x2,\n    y: line.y2\n  };\n  var rotation = label.rotation === 'auto' ? calculateAutoRotation(line) : toRadians(label.rotation);\n  var size = rotatedSize(width, height, rotation);\n  var t = calculateT(line, label, {\n    labelSize: size,\n    padding: padding\n  }, chartArea);\n  var pt = pointInLine(p1, p2, t);\n  var xCoordinateSizes = {\n    size: size.w,\n    min: chartArea.left,\n    max: chartArea.right,\n    padding: padding.left\n  };\n  var yCoordinateSizes = {\n    size: size.h,\n    min: chartArea.top,\n    max: chartArea.bottom,\n    padding: padding.top\n  };\n  return {\n    x: adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust,\n    y: adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust,\n    width: width,\n    height: height,\n    rotation: rotation\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  var cos = Math.cos(rotation);\n  var sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(line, label, sizes, chartArea) {\n  var t;\n  var space = spaceAround(line, chartArea);\n\n  if (label.position === 'start') {\n    t = calculateTAdjust({\n      w: line.x2 - line.x,\n      h: line.y2 - line.y\n    }, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({\n      w: line.x - line.x2,\n      h: line.y - line.y2\n    }, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  var labelSize = sizes.labelSize,\n      padding = sizes.padding;\n  var lineW = lineSize.w * space.dx;\n  var lineH = lineSize.h * space.dy;\n  var x = lineW > 0 && (labelSize.w / 2 + padding.left - space.x) / lineW;\n  var y = lineH > 0 && (labelSize.h / 2 + padding.top - space.y) / lineH;\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(line, chartArea) {\n  var x = line.x,\n      x2 = line.x2,\n      y = line.y,\n      y2 = line.y2;\n  var t = Math.min(y, y2) - chartArea.top;\n  var l = Math.min(x, x2) - chartArea.left;\n  var b = chartArea.bottom - Math.max(y, y2);\n  var r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  var size = labelSizes.size,\n      min = labelSizes.min,\n      max = labelSizes.max,\n      padding = labelSizes.padding;\n  var halfSize = size / 2;\n\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n\n  if (min >= coordinate - padding - halfSize) {\n    coordinate = min + padding + halfSize;\n  }\n\n  if (max <= coordinate + padding + halfSize) {\n    coordinate = max - padding - halfSize;\n  }\n\n  return coordinate;\n}\n\nfunction getArrowHeads(line) {\n  var options = line.options;\n  var arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  var arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\n\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.enabled) {\n    return 0;\n  }\n\n  var length = arrowOpts.length,\n      width = arrowOpts.width;\n  var adjust = line.options.borderWidth / 2;\n  var p1 = {\n    x: length,\n    y: width + adjust\n  };\n  var p2 = {\n    x: 0,\n    y: adjust\n  };\n  return Math.abs(interpolateX(0, p1, p2));\n}\n\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.enabled) {\n    return;\n  }\n\n  var length = arrowOpts.length,\n      width = arrowOpts.width,\n      fill = arrowOpts.fill,\n      backgroundColor = arrowOpts.backgroundColor,\n      borderColor = arrowOpts.borderColor;\n  var arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n\n  ctx.stroke();\n}\n\nvar EllipseAnnotation = /*#__PURE__*/function (_Element3) {\n  _inherits(EllipseAnnotation, _Element3);\n\n  function EllipseAnnotation() {\n    _classCallCheck(this, EllipseAnnotation);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(EllipseAnnotation).apply(this, arguments));\n  }\n\n  _createClass(EllipseAnnotation, [{\n    key: \"inRange\",\n    value: function inRange(mouseX, mouseY, useFinalPosition) {\n      return pointInEllipse({\n        x: mouseX,\n        y: mouseY\n      }, this.getProps(['width', 'height'], useFinalPosition), this.options.rotation, this.options.borderWidth);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(useFinalPosition) {\n      return getRectCenterPoint(this.getProps(['x', 'y', 'width', 'height'], useFinalPosition));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var width = this.width,\n          height = this.height,\n          options = this.options;\n      var center = this.getCenterPoint();\n      ctx.save();\n      translate(ctx, this, options.rotation);\n      setShadowStyle(ctx, this.options);\n      ctx.beginPath();\n      ctx.fillStyle = options.backgroundColor;\n      var stroke = setBorderStyle(ctx, options);\n      ctx.ellipse(center.x, center.y, height / 2, width / 2, PI / 2, 0, 2 * PI);\n      ctx.fill();\n\n      if (stroke) {\n        ctx.shadowColor = options.borderShadowColor;\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }, {\n    key: \"resolveElementProperties\",\n    value: function resolveElementProperties(chart, options) {\n      return getChartRect(chart, options);\n    }\n  }]);\n\n  return EllipseAnnotation;\n}(Element);\n\nEllipseAnnotation.id = 'ellipseAnnotation';\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y'\n};\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointInEllipse(p, ellipse, rotation, borderWidth) {\n  var width = ellipse.width,\n      height = ellipse.height;\n  var center = ellipse.getCenterPoint(true);\n  var xRadius = width / 2;\n  var yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  } // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n\n\n  var angle = toRadians(rotation || 0);\n  var hBorderWidth = borderWidth / 2 || 0;\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n  var a = Math.pow(cosAngle * (p.x - center.x) + sinAngle * (p.y - center.y), 2);\n  var b = Math.pow(sinAngle * (p.x - center.x) - cosAngle * (p.y - center.y), 2);\n  return a / Math.pow(xRadius + hBorderWidth, 2) + b / Math.pow(yRadius + hBorderWidth, 2) <= 1.0001;\n}\n\nvar LabelAnnotation = /*#__PURE__*/function (_Element4) {\n  _inherits(LabelAnnotation, _Element4);\n\n  function LabelAnnotation() {\n    _classCallCheck(this, LabelAnnotation);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LabelAnnotation).apply(this, arguments));\n  }\n\n  _createClass(LabelAnnotation, [{\n    key: \"inRange\",\n    value: function inRange(mouseX, mouseY, useFinalPosition) {\n      var _rotated3 = rotated({\n        x: mouseX,\n        y: mouseY\n      }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation)),\n          x = _rotated3.x,\n          y = _rotated3.y;\n\n      return inBoxRange(x, y, this.getProps(['x', 'y', 'width', 'height'], useFinalPosition), this.options.borderWidth);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(useFinalPosition) {\n      return getRectCenterPoint(this.getProps(['x', 'y', 'width', 'height'], useFinalPosition));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      if (!this.options.content) {\n        return;\n      }\n\n      var labelX = this.labelX,\n          labelY = this.labelY,\n          labelWidth = this.labelWidth,\n          labelHeight = this.labelHeight,\n          options = this.options;\n      ctx.save();\n      translate(ctx, this, options.rotation);\n      drawCallout(ctx, this);\n      drawBox(ctx, this, options);\n\n      _drawLabel(ctx, {\n        x: labelX,\n        y: labelY,\n        width: labelWidth,\n        height: labelHeight\n      }, options);\n\n      ctx.restore();\n    } // TODO: make private in v2\n\n  }, {\n    key: \"resolveElementProperties\",\n    value: function resolveElementProperties(chart, options) {\n      var point = !isBoundToPoint(options) ? getRectCenterPoint(getChartRect(chart, options)) : getChartPoint(chart, options);\n      var padding = toPadding(options.padding);\n      var labelSize = measureLabelSize(chart.ctx, options);\n      var boxSize = measureRect(point, labelSize, options, padding);\n      var hBorderWidth = options.borderWidth / 2;\n\n      var properties = _objectSpread({\n        pointX: point.x,\n        pointY: point.y\n      }, boxSize, {\n        labelX: boxSize.x + padding.left + hBorderWidth,\n        labelY: boxSize.y + padding.top + hBorderWidth,\n        labelWidth: labelSize.width,\n        labelHeight: labelSize.height\n      });\n\n      properties.calloutPosition = options.callout.enabled && resolveCalloutPosition(properties, options.callout, options.rotation);\n      return properties;\n    }\n  }]);\n\n  return LabelAnnotation;\n}(Element);\n\nLabelAnnotation.id = 'labelAnnotation';\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    enabled: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%'\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction measureRect(point, size, options, padding) {\n  var width = size.width + padding.width + options.borderWidth;\n  var height = size.height + padding.height + options.borderWidth;\n  var position = toPosition(options.position);\n  return {\n    x: calculatePosition(point.x, width, options.xAdjust, position.x),\n    y: calculatePosition(point.y, height, options.yAdjust, position.y),\n    width: width,\n    height: height\n  };\n}\n\nfunction calculatePosition(start, size) {\n  var adjust = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var position = arguments.length > 3 ? arguments[3] : undefined;\n  return start - getRelativePosition(size, position) + adjust;\n}\n\nfunction drawCallout(ctx, element) {\n  var pointX = element.pointX,\n      pointY = element.pointY,\n      calloutPosition = element.calloutPosition,\n      options = element.options;\n\n  if (!calloutPosition || element.inRange(pointX, pointY)) {\n    return;\n  }\n\n  var callout = options.callout;\n  ctx.save();\n  ctx.beginPath();\n  var stroke = setBorderStyle(ctx, callout);\n\n  if (!stroke) {\n    return ctx.restore();\n  }\n\n  var _getCalloutSeparatorC = getCalloutSeparatorCoord(element, calloutPosition),\n      separatorStart = _getCalloutSeparatorC.separatorStart,\n      separatorEnd = _getCalloutSeparatorC.separatorEnd;\n\n  var _getCalloutSideCoord = getCalloutSideCoord(element, calloutPosition, separatorStart),\n      sideStart = _getCalloutSideCoord.sideStart,\n      sideEnd = _getCalloutSideCoord.sideEnd;\n\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  var rotatedPoint = rotated({\n    x: pointX,\n    y: pointY\n  }, element.getCenterPoint(), toRadians(-options.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction getCalloutSeparatorCoord(element, position) {\n  var x = element.x,\n      y = element.y,\n      width = element.width,\n      height = element.height;\n  var adjust = getCalloutSeparatorAdjust(element, position);\n  var separatorStart, separatorEnd;\n\n  if (position === 'left' || position === 'right') {\n    separatorStart = {\n      x: x + adjust,\n      y: y\n    };\n    separatorEnd = {\n      x: separatorStart.x,\n      y: separatorStart.y + height\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {\n      x: x,\n      y: y + adjust\n    };\n    separatorEnd = {\n      x: separatorStart.x + width,\n      y: separatorStart.y\n    };\n  }\n\n  return {\n    separatorStart: separatorStart,\n    separatorEnd: separatorEnd\n  };\n}\n\nfunction getCalloutSeparatorAdjust(element, position) {\n  var width = element.width,\n      height = element.height,\n      options = element.options;\n  var adjust = options.callout.margin + options.borderWidth / 2;\n\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n\n  return -adjust;\n}\n\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  var y = element.y,\n      width = element.width,\n      height = element.height,\n      options = element.options;\n  var start = options.callout.start;\n  var side = getCalloutSideAdjust(position, options.callout);\n  var sideStart, sideEnd;\n\n  if (position === 'left' || position === 'right') {\n    sideStart = {\n      x: separatorStart.x,\n      y: y + getSize(height, start)\n    };\n    sideEnd = {\n      x: sideStart.x + side,\n      y: sideStart.y\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {\n      x: separatorStart.x + getSize(width, start),\n      y: separatorStart.y\n    };\n    sideEnd = {\n      x: sideStart.x,\n      y: sideStart.y + side\n    };\n  }\n\n  return {\n    sideStart: sideStart,\n    sideEnd: sideEnd\n  };\n}\n\nfunction getCalloutSideAdjust(position, options) {\n  var side = options.side;\n\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n\n  return side;\n}\n\nfunction resolveCalloutPosition(properties, options, rotation) {\n  var position = options.position;\n\n  if (position === 'left' || position === 'right' || position === 'top' || position === 'bottom') {\n    return position;\n  }\n\n  return resolveCalloutAutoPosition(properties, options, rotation);\n}\n\nvar positions = ['left', 'bottom', 'top', 'right'];\n\nfunction resolveCalloutAutoPosition(properties, options, rotation) {\n  var x = properties.x,\n      y = properties.y,\n      width = properties.width,\n      height = properties.height,\n      pointX = properties.pointX,\n      pointY = properties.pointY;\n  var center = {\n    x: x + width / 2,\n    y: y + height / 2\n  };\n  var start = options.start;\n  var xAdjust = getSize(width, start);\n  var yAdjust = getSize(height, start);\n  var xPoints = [x, x + xAdjust, x + xAdjust, x + width];\n  var yPoints = [y + yAdjust, y + height, y, y + yAdjust];\n  var result = [];\n\n  for (var index = 0; index < 4; index++) {\n    var rotatedPoint = rotated({\n      x: xPoints[index],\n      y: yPoints[index]\n    }, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {\n        x: pointX,\n        y: pointY\n      })\n    });\n  }\n\n  return result.sort(function (a, b) {\n    return a.distance - b.distance;\n  })[0].position;\n}\n\nvar PointAnnotation = /*#__PURE__*/function (_Element5) {\n  _inherits(PointAnnotation, _Element5);\n\n  function PointAnnotation() {\n    _classCallCheck(this, PointAnnotation);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PointAnnotation).apply(this, arguments));\n  }\n\n  _createClass(PointAnnotation, [{\n    key: \"inRange\",\n    value: function inRange(mouseX, mouseY, useFinalPosition) {\n      var _this$getProps3 = this.getProps(['width'], useFinalPosition),\n          width = _this$getProps3.width;\n\n      return inPointRange({\n        x: mouseX,\n        y: mouseY\n      }, this.getCenterPoint(useFinalPosition), width / 2, this.options.borderWidth);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(useFinalPosition) {\n      return getElementCenterPoint(this, useFinalPosition);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var options = this.options;\n      var borderWidth = options.borderWidth;\n\n      if (options.radius < 0.1) {\n        return;\n      }\n\n      ctx.save();\n      ctx.fillStyle = options.backgroundColor;\n      setShadowStyle(ctx, options);\n      var stroke = setBorderStyle(ctx, options);\n      options.borderWidth = 0;\n      drawPoint(ctx, options, this.x, this.y);\n\n      if (stroke && !isImageOrCanvas(options.pointStyle)) {\n        ctx.shadowColor = options.borderShadowColor;\n        ctx.stroke();\n      }\n\n      ctx.restore();\n      options.borderWidth = borderWidth;\n    }\n  }, {\n    key: \"resolveElementProperties\",\n    value: function resolveElementProperties(chart, options) {\n      return resolvePointPosition(chart, options);\n    }\n  }]);\n\n  return PointAnnotation;\n}(Element);\n\nPointAnnotation.id = 'pointAnnotation';\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nvar PolygonAnnotation = /*#__PURE__*/function (_Element6) {\n  _inherits(PolygonAnnotation, _Element6);\n\n  function PolygonAnnotation() {\n    _classCallCheck(this, PolygonAnnotation);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PolygonAnnotation).apply(this, arguments));\n  }\n\n  _createClass(PolygonAnnotation, [{\n    key: \"inRange\",\n    value: function inRange(mouseX, mouseY, useFinalPosition) {\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(useFinalPosition) {\n      return getElementCenterPoint(this, useFinalPosition);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var elements = this.elements,\n          options = this.options;\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = options.backgroundColor;\n      setShadowStyle(ctx, options);\n      var stroke = setBorderStyle(ctx, options);\n      var first = true;\n\n      var _iterator5 = _createForOfIteratorHelper(elements),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var el = _step5.value;\n\n          if (first) {\n            ctx.moveTo(el.x, el.y);\n            first = false;\n          } else {\n            ctx.lineTo(el.x, el.y);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      ctx.closePath();\n      ctx.fill(); // If no border, don't draw it\n\n      if (stroke) {\n        ctx.shadowColor = options.borderShadowColor;\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }, {\n    key: \"resolveElementProperties\",\n    value: function resolveElementProperties(chart, options) {\n      var _resolvePointPosition = resolvePointPosition(chart, options),\n          x = _resolvePointPosition.x,\n          y = _resolvePointPosition.y,\n          width = _resolvePointPosition.width,\n          height = _resolvePointPosition.height;\n\n      var sides = options.sides,\n          radius = options.radius,\n          rotation = options.rotation,\n          borderWidth = options.borderWidth;\n      var halfBorder = borderWidth / 2;\n      var elements = [];\n      var angle = 2 * PI / sides;\n      var rad = rotation * RAD_PER_DEG;\n\n      for (var i = 0; i < sides; i++, rad += angle) {\n        var sin = Math.sin(rad);\n        var cos = Math.cos(rad);\n        elements.push({\n          type: 'point',\n          optionScope: 'point',\n          properties: {\n            x: x + sin * radius,\n            y: y - cos * radius,\n            bX: x + sin * (radius + halfBorder),\n            bY: y - cos * (radius + halfBorder)\n          }\n        });\n      }\n\n      return {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        elements: elements,\n        initProperties: {\n          x: x,\n          y: y\n        }\n      };\n    }\n  }]);\n\n  return PolygonAnnotation;\n}(Element);\n\nPolygonAnnotation.id = 'polygonAnnotation';\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  var isInside = false;\n  var A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n\n  var _iterator6 = _createForOfIteratorHelper(points),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var point = _step6.value;\n      var B = point.getProps(['bX', 'bY'], useFinalPosition);\n\n      if (B.bY > y !== A.bY > y && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n        isInside = !isInside;\n      }\n\n      A = B;\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return isInside;\n}\n\nvar annotationTypes = {\n  box: BoxAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n/**\n * Register fallback for annotation elements\n * For example lineAnnotation options would be looked through:\n * - the annotation object (options.plugins.annotation.annotations[id])\n * - element options (options.elements.lineAnnotation)\n * - element defaults (defaults.elements.lineAnnotation)\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\n */\n\nObject.keys(annotationTypes).forEach(function (key) {\n  defaults.describe(\"elements.\".concat(annotationTypes[key].id), {\n    _fallback: 'plugins.annotation'\n  });\n});\nvar directUpdater = {\n  update: Object.assign\n};\n/**\n * Resolve the annotation type, checking if is supported.\n * @param {string} [type=line] - annotation type\n * @returns {string} resolved annotation type\n */\n\nfunction resolveType() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'line';\n\n  if (annotationTypes[type]) {\n    return type;\n  }\n\n  console.warn(\"Unknown annotation type: '\".concat(type, \"', defaulting to 'line'\"));\n  return 'line';\n}\n/**\n * Create or update all annotation elements, configured to the plugin.\n * @param {Chart} chart - the chart where the plugin is enabled\n * @param {Object} state - the state of the plugin\n * @param {Object} options - annotation options to use\n * @param {UpdateMode} mode - The update mode\n */\n\n\nfunction updateElements(chart, state, options, mode) {\n  var animations = resolveAnimations(chart, options.animations, mode);\n  var annotations = state.annotations;\n  var elements = resyncElements(state.elements, annotations);\n\n  for (var i = 0; i < annotations.length; i++) {\n    var annotationOptions = annotations[i];\n    var element = getOrCreateElement(elements, i, annotationOptions.type);\n    var resolver = annotationOptions.setContext(getContext(chart, element, annotationOptions));\n    var properties = element.resolveElementProperties(chart, resolver);\n    properties.skip = toSkip(properties);\n\n    if ('elements' in properties) {\n      updateSubElements(element, properties, resolver, animations); // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n\n      delete properties.elements;\n    }\n\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n\n    properties.options = resolveAnnotationOptions(resolver);\n    animations.update(element, properties);\n  }\n}\n\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n\n  return new Animations(chart, animOpts);\n}\n\nfunction updateSubElements(mainElement, _ref6, resolver, animations) {\n  var elements = _ref6.elements,\n      initProperties = _ref6.initProperties;\n  var subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n\n  for (var i = 0; i < elements.length; i++) {\n    var definition = elements[i];\n    var properties = definition.properties;\n    var subElement = getOrCreateElement(subElements, i, definition.type, initProperties);\n    var subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\n\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  var elementClass = annotationTypes[resolveType(type)];\n  var element = elements[index];\n\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n\n    if (isObject(initProperties)) {\n      Object.assign(element, initProperties);\n    }\n  }\n\n  return element;\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  var elementClass = annotationTypes[resolveType(resolver.type)];\n  var result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elementClass.defaults), resolveObj(resolver, elementClass.defaultRoutes));\n\n  var _iterator7 = _createForOfIteratorHelper(hooks),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var hook = _step7.value;\n      result[hook] = resolver[hook];\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  var result = {};\n\n  for (var _i4 = 0, _Object$keys2 = Object.keys(defs); _i4 < _Object$keys2.length; _i4++) {\n    var prop = _Object$keys2[_i4];\n    var optDefs = defs[prop];\n    var value = resolver[prop];\n    result[prop] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n\n  return result;\n}\n\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element: element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  var count = annotations.length;\n  var start = elements.length;\n\n  if (start < count) {\n    var add = count - start;\n    elements.splice.apply(elements, [start, 0].concat(_toConsumableArray(new Array(add))));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n\n  return elements;\n}\n\nvar name = \"chartjs-plugin-annotation\";\nvar version = \"1.4.0\";\nvar chartStates = new Map();\nvar annotation = {\n  id: 'annotation',\n  version: version,\n\n  /* TODO: enable in v2\n  beforeRegister() {\n    requireVersion('chart.js', '3.7', Chart.version);\n  },\n  */\n  afterRegister: function afterRegister() {\n    Chart.register(annotationTypes); // TODO: Remove this check, warning and workaround in v2\n\n    if (!requireVersion('chart.js', '3.7', Chart.version, false)) {\n      console.warn(\"\".concat(name, \" has known issues with chart.js versions prior to 3.7, please consider upgrading.\")); // Workaround for https://github.com/chartjs/chartjs-plugin-annotation/issues/572\n\n      Chart.defaults.set('elements.lineAnnotation', {\n        callout: {},\n        font: {},\n        padding: 6\n      });\n    }\n  },\n  afterUnregister: function afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n  beforeInit: function beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false\n    });\n  },\n  beforeUpdate: function beforeUpdate(chart, args, options) {\n    var state = chartStates.get(chart);\n    var annotations = state.annotations = [];\n    var annotationOptions = options.annotations;\n\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(function (key) {\n        var value = annotationOptions[key];\n\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push.apply(annotations, _toConsumableArray(annotationOptions));\n    }\n\n    verifyScaleOptions(annotations, chart.scales);\n  },\n  afterDataLimits: function afterDataLimits(chart, args) {\n    var state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(function (a) {\n      return a.display && a.adjustScaleRange;\n    }));\n  },\n  afterUpdate: function afterUpdate(chart, args, options) {\n    var state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(function (el) {\n      return !el.skip && el.options.display;\n    });\n  },\n  beforeDatasetsDraw: function beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n  afterDatasetsDraw: function afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n  beforeDraw: function beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n  afterDraw: function afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n  beforeEvent: function beforeEvent(chart, args, options) {\n    var state = chartStates.get(chart);\n    handleEvent(state, args.event, options);\n  },\n  destroy: function destroy(chart) {\n    chartStates.delete(chart);\n  },\n  _getState: function _getState(chart) {\n    return chartStates.get(chart);\n  },\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'pointX', 'pointY', 'labelX', 'labelY', 'labelWidth', 'labelHeight', 'radius'],\n        type: 'number'\n      }\n    },\n    clip: true,\n    dblClickSpeed: 350,\n    // ms\n    drawTime: 'afterDatasetsDraw',\n    label: {\n      drawTime: null\n    }\n  },\n  descriptors: {\n    _indexable: false,\n    _scriptable: function _scriptable(prop) {\n      return !hooks.includes(prop);\n    },\n    annotations: {\n      _allKeys: false,\n      _fallback: function _fallback(prop, opts) {\n        return \"elements.\".concat(annotationTypes[resolveType(opts.type)].id);\n      }\n    }\n  },\n  additionalOptionScopes: ['']\n};\n\nfunction draw(chart, caller, clip) {\n  var ctx = chart.ctx,\n      chartArea = chart.chartArea;\n\n  var _chartStates$get = chartStates.get(chart),\n      visibleElements = _chartStates$get.visibleElements;\n\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n\n  drawElements(ctx, visibleElements, caller);\n  drawSubElements(ctx, visibleElements, caller);\n\n  if (clip) {\n    unclipArea(ctx);\n  }\n\n  visibleElements.forEach(function (el) {\n    if (!('drawLabel' in el)) {\n      return;\n    }\n\n    var label = el.options.label;\n\n    if (label && label.enabled && label.content && (label.drawTime || el.options.drawTime) === caller) {\n      el.drawLabel(ctx, chartArea);\n    }\n  });\n}\n\nfunction drawElements(ctx, elements, caller) {\n  var _iterator8 = _createForOfIteratorHelper(elements),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var el = _step8.value;\n\n      if (el.options.drawTime === caller) {\n        el.draw(ctx);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\n\nfunction drawSubElements(ctx, elements, caller) {\n  var _iterator9 = _createForOfIteratorHelper(elements),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var el = _step9.value;\n\n      if (isArray(el.elements)) {\n        drawElements(ctx, el.elements, caller);\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n}\n\nexport { annotation as default };","map":null,"metadata":{},"sourceType":"module"}