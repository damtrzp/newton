{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.interval = exports.builtIn = void 0;\n\nconst built_in_math_eval_1 = __importDefault(require(\"built-in-math-eval\"));\n\nconst interval_arithmetic_eval_1 = __importDefault(require(\"interval-arithmetic-eval\"));\n\nconst samplers = {\n  interval: interval_arithmetic_eval_1.default,\n  builtIn: built_in_math_eval_1.default\n};\n\nif (global.math) {\n  samplers.builtIn = global.math.compile;\n}\n\nfunction generateEvaluator(samplerName) {\n  function doCompile(expression) {\n    // compiles does the following\n    //\n    // when expression === string\n    //\n    //     gen = new require('math-codegen')\n    //     return gen.parse(expression).compile(Interval|BultInMath)\n    //\n    //     which is an object with the form\n    //\n    //     {\n    //       eval: function (scope) {\n    //         // math-codegen magic\n    //       }\n    //     }\n    //\n    // when expression === function\n    //\n    //    {\n    //      eval: expression\n    //    }\n    //\n    // othewise throw an error\n    if (typeof expression === 'string') {\n      const compiled = samplers[samplerName](expression);\n\n      if (global.math && samplerName === 'builtIn') {\n        // if mathjs is included use its evaluate method instead\n        return {\n          eval: compiled.evaluate || compiled.eval\n        };\n      }\n\n      return compiled;\n    } else if (typeof expression === 'function') {\n      return {\n        eval: expression\n      };\n    } else {\n      throw Error('expression must be a string or a function');\n    }\n  }\n\n  function compileIfPossible(meta, property) {\n    // compile the function using interval arithmetic, cache the result\n    // so that multiple calls with the same argument don't trigger the\n    // kinda expensive compilation process\n    const expression = meta[property];\n    const hiddenProperty = samplerName + '_Expression_' + property;\n    const hiddenCompiled = samplerName + '_Compiled_' + property;\n\n    if (expression !== meta[hiddenProperty]) {\n      meta[hiddenProperty] = expression;\n      meta[hiddenCompiled] = doCompile(expression);\n    }\n  }\n\n  function getCompiledExpression(meta, property) {\n    return meta[samplerName + '_Compiled_' + property];\n  }\n  /**\n   * Evaluates meta[property] with `variables`\n   *\n   * - Compiles meta[property] if it wasn't compiled already (also with cache\n   *   check)\n   * - Evaluates the resulting function with the merge of meta.scope and\n   *   `variables`\n   *\n   * @param {Object} meta\n   * @param {String} property\n   * @param {Object} variables\n   * @returns {Number|Array} The builtIn evaluator returns a number, the\n   * interval evaluator an array\n   */\n\n\n  function evaluate(meta, property, variables) {\n    // e.g.\n    //\n    //  meta: {\n    //    fn: 'x + 3',\n    //    scope: { y: 3 }\n    //  }\n    //  property: 'fn'\n    //  variables:  { x: 3 }\n    //\n    compileIfPossible(meta, property);\n    return getCompiledExpression(meta, property).eval(Object.assign({}, meta.scope || {}, variables));\n  }\n\n  return evaluate;\n}\n\nconst builtIn = generateEvaluator('builtIn');\nexports.builtIn = builtIn;\nconst interval = generateEvaluator('interval');\nexports.interval = interval;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AAEA,MAAMA,QAAQ,GAAG;EACfC,QAAQ,EAAEC,kCADK;EAEfC,OAAO,EAAEC;AAFM,CAAjB;;AAKA,IAAKC,MAAc,CAACC,IAApB,EAA0B;EACxBN,QAAQ,CAACG,OAAT,GAAoBE,MAAc,CAACC,IAAf,CAAoBC,OAAxC;AACD;;AAED,SAASC,iBAAT,CAA4BC,WAA5B,EAA+D;EAC7D,SAASC,SAAT,CAAoBC,UAApB,EAAsE;IACpE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;MAClC,MAAMC,QAAQ,GAAGZ,QAAQ,CAACS,WAAD,CAAR,CAAsBE,UAAtB,CAAjB;;MACA,IAAKN,MAAc,CAACC,IAAf,IAAuBG,WAAW,KAAK,SAA5C,EAAuD;QACrD;QACA,OAAO;UAAEI,IAAI,EAAED,QAAQ,CAACE,QAAT,IAAqBF,QAAQ,CAACC;QAAtC,CAAP;MACD;;MACD,OAAOD,QAAP;IACD,CAPD,MAOO,IAAI,OAAOD,UAAP,KAAsB,UAA1B,EAAsC;MAC3C,OAAO;QAAEE,IAAI,EAAEF;MAAR,CAAP;IACD,CAFM,MAEA;MACL,MAAMI,KAAK,CAAC,2CAAD,CAAX;IACD;EACF;;EAED,SAASC,iBAAT,CAA4BC,IAA5B,EAAuCC,QAAvC,EAAuD;IACrD;IACA;IACA;IACA,MAAMP,UAAU,GAAGM,IAAI,CAACC,QAAD,CAAvB;IACA,MAAMC,cAAc,GAAGV,WAAW,GAAG,cAAd,GAA+BS,QAAtD;IACA,MAAME,cAAc,GAAGX,WAAW,GAAG,YAAd,GAA6BS,QAApD;;IACA,IAAIP,UAAU,KAAKM,IAAI,CAACE,cAAD,CAAvB,EAAyC;MACvCF,IAAI,CAACE,cAAD,CAAJ,GAAuBR,UAAvB;MACAM,IAAI,CAACG,cAAD,CAAJ,GAAuBV,SAAS,CAACC,UAAD,CAAhC;IACD;EACF;;EAED,SAASU,qBAAT,CAAgCJ,IAAhC,EAA2CC,QAA3C,EAA2D;IACzD,OAAOD,IAAI,CAACR,WAAW,GAAG,YAAd,GAA6BS,QAA9B,CAAX;EACD;EAED;;;;;;;;;;;;;;;;EAcA,SAASJ,QAAT,CAAmBG,IAAnB,EAA8BC,QAA9B,EAAgDI,SAAhD,EAA8D;IAC5D;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAN,iBAAiB,CAACC,IAAD,EAAOC,QAAP,CAAjB;IAEA,OAAOG,qBAAqB,CAACJ,IAAD,EAAOC,QAAP,CAArB,CAAsCL,IAAtC,CACLU,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBP,IAAI,CAACQ,KAAL,IAAc,EAAhC,EAAoCH,SAApC,CADK,CAAP;EAGD;;EAED,OAAOR,QAAP;AACD;;AAED,MAAMX,OAAO,GAAGK,iBAAiB,CAAC,SAAD,CAAjC;AAGSkB;AAFT,MAAMzB,QAAQ,GAAGO,iBAAiB,CAAC,UAAD,CAAlC;AAEkBkB","names":["samplers","interval","interval_arithmetic_eval_1","builtIn","built_in_math_eval_1","global","math","compile","generateEvaluator","samplerName","doCompile","expression","compiled","eval","evaluate","Error","compileIfPossible","meta","property","hiddenProperty","hiddenCompiled","getCompiledExpression","variables","Object","assign","scope","exports"],"sources":["../../src/helpers/eval.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}